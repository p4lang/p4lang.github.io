---
layout: post
title: "Announcing the P4Runtime v1.1 release"
date: 2020-03-09
author: "Antonin Bas"
category: p4
header-img: assets/p4-background.png
---

We are excited to announce the release of [P4Runtime v1.1.0][p4runtime-spec],
almost exactly a year after the [1.0.0 release][p4runtime-1.0-blog]! Congrats to
everyone in the P4 API Working Group for making this possible and continuing to
improve the quality of the P4Runtime API and specification document.

The end of 2019 was big for P4Runtime, with ONF
[announcing][stratum-announcement] that the Stratum project was released as
open-source. This makes Stratum the first open switch OS to offer P4Runtime as a
northbound interface, with multiple [hardware platforms][stratum-hw] already
supported. If you do not have access to hardware, fret not as Stratum also
supports the [bmv2 simulator][stratum-bmv2], which anyone can run on a Linux
system.

## Notable Changes in P4Runtime v1.1

For the full list of changes, refer to the [revision history](revision-history).

### Major Overhaul of Master-Arbitration

The P4Runtime interface allows multiple controllers to be connected to the
P4Runtime server running on the device at the same time: one master controller -
the only one with write access to the device - and potentially several stand-by
controllers. Each controller has a numerical election ID, usually assigned
through a leader election algorithm (e.g. Paxos, as implemented in [Chubby]),
which it advertises to the server, with the master being the controller with the
highest election ID. In case the master goes offline, one of the stand-by
controllers is available to take its place. In P4Runtime v1.0, this hand-over
was automatic and handled entirely by the server: upon detecting that the master
had disconnected, the server would look for the controller with the next highest
election ID, and appoint it in its place. The P4 API Working Group received
feedback from Google and ONF engineers implementing SDN controllers that this
could lead to issues in production deployments. In particular, in case of a
network partition, it is possible for a controller in a minority partition to
gain write access to the device. To address this issue in P4Runtime v1.1, we
specified that the master election ID at each P4Runtime server must be strictly
monotonically increasing. While this is a significant change for P4Runtime
server implementations, the Working Group felt that it did not warrant
increasing the major version number for the P4Runtime API, as the format of the
Protobuf messages did not change.

### New `error` Field to Report Stream errors

This is another change that was requested by P4Runtime users. It enables the
server to asynchronously report an error back when the controller sends an
invalid message on the bi-directional stream, without shutting-down the stream
altogether.

This is what the `StreamMessageResponse` message now looks like in P4Runtime
v1.1:
```protobuf
message StreamMessageResponse {
  oneof update {
    MasterArbitrationUpdate arbitration = 1;
    PacketIn packet = 2;
    DigestList digest = 3;
    IdleTimeoutNotification idle_timeout_notification = 4;
    .google.protobuf.Any other = 5;
    // Used by the server to asynchronously report errors which occur when
    // processing StreamMessageRequest messages.
    StreamError error = 6;
  }
}
```

A typical use-case is for the server to use this new `error` field when a
packet-out sent by the controller is invalid or not supported by the device. For
example, if a packet-out exceeds the MTU (Maximum Transmission Unit) for the
egress link, the server may generate the following `StreamMessageResponse`:
```
error {
 canonical_code: 3  # INVALID_ARGUMENT
 message: "Packet exceeds the MTU for port."
 space: "targetX-psa-vendor1"
 code: 123  # MTU_EXCEEDED
 packet_out {
   # we do not set the packet_out field as it does not provide any
   # extra information to the client
 }
}
```

### New `Capabilities` RPC

Now that P4Runtime has minor releases, it may be necessary for a client to have
a mechanism through which to detect the exact version P4Runtime version
implemented by the server, in order to determine which feature set is
available. This is now possible thanks to a new `Capabilities` RPC, inspired by
the one found in [gNMI][gnmi-capabilities]:
```protobuf
service P4Runtime {
  // ...

  rpc Capabilities(CapabilitiesRequest) returns (CapabilitiesResponse) {
  }
}

message CapabilitiesRequest {
}

message CapabilitiesResponse {
  // The full semantic version string (e.g. "1.1.0-rc.1") corresponding to the
  // version of the P4Runtime API currently implemented by the server.
  string p4runtime_api_version = 1;
}
```

At the moment, the response only includes a semantic version string. In the
future, we may consider providing additional information: for fixed-function
devices, this may include a well-known set of P4 programs that are supported by
the device, similarly to how the gNMI `Capabilities` RPC returns a list of YANG
models implemented by the server.

### Support for Wildcard Reads for Multicast Groups and Clone Sessions

One shortcoming of P4Runtime v1.0 is the inability for the controller to
retrieve the entire list of multicast group entries or clone session entries
programmed into the device. This makes it difficult to implement reconciliation
correctly at the controller, since there is no way to read these entries without
assuming that their numerical identifiers are already known. This was addressed
in P4Runtime (without any change to the message format), and "wildcard" reads
are now supported for multicast groups and clone sessions, just like they are
for every other object (tables, counters, etc.).

## Looking Forward

Looking forward to 2020, the Working Group has already several projects on its
radar:
 * **P4Runtime v1.2**: it seems that we will not have to wait a year for the
   next minor release! P4Runtime v1.2 should come in time for the [P4
   Summit][p4-summit] and - among other things - will include support for the
   `OPTIONAL` match kind and P4 structured annotations.
 * **Golang bindings on Github**: we are working on publishing the Go bindings
   generated by the Protobuf compiler to the [p4lang/p4runtime] Github repo, so
   that they can more easily be consummed by third-party Go applications.
 * **P4Runtime v2.0?**: while there is nothing concrete yet, we already have
   great [long-term ideas] on how to make P4Runtime even better and this is
   something we will keep exploring.

If you'd like to get involved, please consider joining our [bi-weekly
meetings][p4runtime-community]. We also welcome all suggestions so don't
hesitate to open an [issue][p4runtime-issues] on Github, and of course we are
always eager for user feedback.


[p4runtime-spec]: https://p4.org/p4runtime/spec/v1.1.0/P4Runtime-Spec.html
[p4runtime-1.0-blog]: https://p4.org/p4/p4runtime-v1-release
[stratum-announcement]: https://www.opennetworking.org/news-and-events/press-releases/onf-announces-stratum-project-now-available-as-open-source-completes-incubation-development/
[stratum-hw]: https://github.com/stratum/stratum#supported-devices
[stratum-bmv2]: https://github.com/stratum/tutorial
[revision-history]: https://p4.org/p4runtime/spec/v1.1.0/P4Runtime-Spec.html#sec-changes-in-v110
[Chubby]: https://static.googleusercontent.com/media/research.google.com/en//archive/chubby-osdi06.pdf
[gnmi-capabilities]: https://github.com/openconfig/gnmi/blob/master/proto/gnmi/gnmi.proto#L51
[p4-summit]: https://www.opennetworking.org/events/p4-2020-workshop/
[p4lang/p4runtime]: https://github.com/p4lang/p4runtime
[long-term ideas]: https://github.com/p4lang/p4runtime/projects/1
[p4runtime-community]: https://github.com/p4lang/p4runtime#community
[p4runtime-issues]: https://github.com/p4lang/p4runtime/issues
